import { ArticleLayout } from "@libs/blog/components/article-layout";

export const article = {
  author: "Ying Wang",
  date: "2017-10-31",
  title: "Stateless Backends",
  description: "Stateless Backends",
  categories: ["Software"],
};

export const metadata = {
  title: article.title,
  description: article.description,
};

export default (props) => (
  <ArticleLayout article={article} theme="solarized" {...props} />
);

The CEO of the company I work at has no goal or dream in life. I know this because I asked him point-blank during a one-on-one lunch, "What is your goal, or dream, in life?", and he stuttered for fifteen seconds before proceeding to switch topics. He also responded to "What books do you read on a regular basis" with "I read a lot, and a lot of different genres too" and "What do you know about software engineering management" with "Nothing, that's why I have the CTO". I tried talking about why it's important to learn a core competency required to lead a software company, but he brushed it off.

Lesson to self: don't say or do any of that to any subordinates I have in the future, because it does not induce confidence.

So I was not surprised yesterday (Monday) morning when he came into the office and said that he talked things over with the CTO the Friday evening prior, and decided we needed to support injection molding for our customers by Wednesday morning this week.

For starters, I'm not sure what business we have being in injection molding. Injection molding is that process that makes pretty much every commercial plastic product, like those Dixie cups and plastic silverware. It is usually not done for part quantities less than ten thousand, because the molds have to be so complex and well-designed. I'm not sure exactly why we would have an instant quoting capability for injection molding in that case, because the base costs for injection molding run into at least single-digit millions (given operational, personnel, and other business expenses), and it's not something people choose to do spur-of-the-moment, like with 3D printing. You can quote offline and still make a decent margin, because one-time quoting costs should be well amortized over the large part quantity. I guess it could be a pivot, but if we're suddenly getting multimillion-dollar orders from a few big companies, we run the risk of turning into a contracting shop instead of a company with a product.

In any case, we had been working on supporting injection molding for some time now, but now the timeline was accelerated because apparently the CTO had promised the venture capitalists and board of directors that we would have it done by then, and did not take into account the slippage in our schedules over the past few months, or report them to the stakeholders. In other words, we need to develop an entirely new feature, make it usable, have it tested, and deployed to production within _36 hours_. In addition, there was to be no publicity or information given to our customers about this feature, because this deadline was only expected by our investors.

The design of the website was specced out as the website was being developed. In the same process, multiple bugs on our quoting flow were found, because the satellite office works on specifically that product, and those bugs needed to be fixed while integrating this new feature. They weren't there for this, of course, even though this is technically their feature (honestly though, probably for the better). There are no tests, no stories, and no estimates. Again, all of this, in production, in _36 hours_. We can also give up hope that this will be a prototype we can throw away, because the CTO said our application is "just a little HTML" (verbatim) and we would have _two whole days_ in order to make it "perfect" (verbatim).

I'm working on this yet, but my colleagues are. They're pretty smart about this; I think their plan is to build a lightweight form that looks pretty for investors in order to submit {an email, a note, etc.} to operations, and let them take it from there. Even so, I expect us to be like this for the next few days:

[Crashing](/img/posts/2017/10/31/stateless_backends_1.gif)

---

There has been some positive news this week, on my end at least :sweat*smile: : my changes for separate coverage reports and testing coverage for our pricing repositories were finally merged into our main development branch, so I can \_officially* say that I did this work. Difference is, it matters to everyone now. Curious enough, some unit tests for pricing our 3D printing began failing after the merge, and I traced it back to a missing commit for a function that did not return anything. Good old unit tests and good old gated commits. I fixed that and pushed up the change, and life in pricing land is _good_.

My development environment also broke because I uninstalled a Python standard module by accident (lesson to self: check the packages that are uninstalled when you run `pip uninstall ${PACKAGE_NAME}`), **BUT BUT BUT** I had an encrypted backup of my machine on an external hard drive, and was able to restore my computer's state to before that happened. That took two hours; setting up my development environment took me three days with help from people who no longer work here, so I figure the restore was a good deal faster than fixing my environment. I was pleased.

---

Speaking of state, let's cut to today's topic of discussion: stateless backends. When I first heard of "stateless backend", I was skeptical. "Isn't the whole point of a server to provide state?" was my first thought. Now, I realize that state was just referring to state _stored on the server_, rather than on a database. Then, I was like, "how do you work with state if you cannot store state on the backend?"

The answer: _do everything in the front-end, and write back to the back-end when you are ready. The back-end should then only need to write the data straight to the database_.

The other answer: _yes, REST is stateless, but that's why there's RESTful_.

I'm working on both the back-end and front-end application implementation for the hackathon this weekend while my teammates work on machine learning, and I realized I could get away with a stateless back-end. I'm skipping auth because it's a hackathon, so no need to store that anywhere, and records are fairly straightforward because they give us a preliminary schema already. Yes, it's a mongo schema :angry: , but there are mongo to SQL things you can do and hopefully we can get that straightened out in time.

(As an aside, there are streaming APIs that will be activated during the hackathon. :eyes:')

So what you can do is build out an API like:

```bash
curl -X GET https://api.example.com/v1/users/<user_id>
```

and have that request literally do something like:

```python
class User(Resource):
  def get(self, user_id):
    return db_interface.get_user(user_id)
```

...

See how simple that was?!?! Your back-end is literally just connecting the API and the database together!!! No in-transit state anywhere! _WOOOOO_

Well then what about `POST`? Something like:

```bash
curl --data "user_id=value&data=value2" https://api.example.com/v1/users/
```

...then you do something like:

```python
class User(Resource):
  def post(self, user_id, data):
    return db_interface.write_user(user_id, data)
```

No in-transit state yet again! _AYYYYYYY_

At least I hope it's that simple. Might be missing something. But this is simple to work with, and that's what I care about!

What if you're trying to do something complicated, like check out? Do you need an API endpoint like `https://api.example.com/v1/checkout`?

Maybe, maybe not. If you have an `orders` table in your database and an association table between `users` and `orders`, you can do something like:

```bash
# Upon checkout
curl --data "user_id=value&order_data=value2" https://api.example.com/v1/orders/
```

```python
class Order(Resource):
  def post(self, user_id, order_data):
    # Adds an association between newly created order and user with user_id
    # Adds the order to the orders table
    return db_interface.write_order(user_id, order_data)
```

See how we can skip having a non-REST `checkout` endpoint?

A good thing about having a stateless backend is that you can scale it. You don't care about the state stored on the server, because there _is_ no state stored on the server that you care about, so any server with that application and configuration can handle the same API specification. You can scale your server instances without having to worry about changing your code, a DevOps's wet dream. If your database and bandwidth requirements grow to the point where transactional consistency becomes an issue, use a "NewSQL" solution, like GCP Spanner or CockroachDB, or shard / federate your database, or what have you.

I'm coming from a NoSQL background, and I'm also pretty inexperienced with software engineering so far, but this all seems to be a lot more straightforward to me (a human and a developer) than the alternatives.

---

Still not convinced stateless backends are good? Let me share with you two horror stories from my time here that may make you change your mind.

Flask is a _very_ loose micro-framework, and we did not have much insight into how to architect things from the beginning. When we save records into our (NoSQL) database, we specify a `clean()` method for that record that runs through a bunch of methods to ensure that our data integrity is ship-shape. Due to our high turnover, nobody knows today how exactly our data is cleaned. Brace yourselves.

We have our `save()` methods sprinkled throughout our codebase. There is no uniform interface for how our back-end interacts with our database. Remember, every time we call `save()`, we `clean()` as well. Over time, these `clean()` methods become gigantic, totaling about twenty or thirty methods each, some of which also `save()` on different records, which calls `clean()`.

Our performance started sucking about a few months into this year. It turned out we were calling `clean()` a couple dozen times for each call to our API endpoint. This means we call our database a few dozen times for each call to our API endpoint. We were no longer "instantly quoting" something. This impacted our core business advantage. One of my colleagues fixed it, but not before he was threatened twice with immediate dismissal for coming into the office fifteen minutes late, and not before we had refactored out our (my beloved) pricing algorithms, which ultimately did not make as much of a performance impact as we had thought / hoped.

In addition, those `clean()` methods to ensure data integrity do not do their job. Sometimes, when we update a record, to add a discount or a coupon, or to PATCH a surcharge, it does not get written to the database, or gets written multiple times. Thousands of records have suffered this fate. When you don't know how much you _actually_ charged thousands of customers, and when your CFO does not have a CPA license and thus may or may not be able to figure this out... **THINGS. ARE. BAD.**

So why do we have a `clean()` method? Because we store state locally on our servers, we manipulate it in-memory, and so we're not sure what the state of the record is when we write it back. Sure, some of the issue has to do with SQL vs. NoSQL, but a lot of the blame goes to having a stateful-ish back-end.

Why don't we get rid of those `clean()` methods? Great idea, why didn't we think of that? Just get _rid of those clean methods_! Okay, I don't have to be a prick about it, but they're embedded into our codebase, they're everywhere, without them we'd be in an even worse position regarding the state of our in-memory records, and we don't know how they work. It's literally the eventuality of a Faustian bargain.

:fire: Leave us, save yourselves! :fire:
