import { ArticleLayout } from "@libs/blog/components/article-layout";

export const article = {
  author: "Ying Wang",
  date: "2017-10-21",
  title: "There are two kinds of software engineers",
  description: "There are two kinds of software engineers",
  categories: ["Software"],
};

export const metadata = {
  title: article.title,
  description: article.description,
};

export default (props) => (
  <ArticleLayout article={article} theme="solarized" {...props} />
);

Today I will talk about two types of software engineers at my company -- ones with whom I have grown to work with very well, and ones with whom I hate with all my being. So really just the competent vs. the incompetent.

Let's start with the incompetent, one to get it out of the way and two because there's both nothing and too much technical matter to discuss with them. Their primary con is that they have significant character defects. When the competent leave this company and those remaining lament their loss, the incompetent are the ones who say things like, "I'm much smarter than he is" (that was verbatim). This would be unwelcome even if it is true, which it is not by a long mile. They indeed contribute negative work towards the company. Through secretive pull request reviews and approvals to each other (as noted in ["That Happened"](/posts/2017/10/04/that_happened)), they get through the normal checks put into place for our repositories and break releases. Then, the competent must spend their time digging through incompetent, broken code in order to figure out what went wrong. This happens on a routine basis.

Believe it or not, management cares more about the negativity of the competent software engineers as they are forced from feature development, refactoring, and :fire:-ing everything down to start over to fix these issues than they are about the lack of competency from the people who routinely cause these defects. So of course, the incompetent are free and proud to display their ignorance.

For example, here's what one incompetent replied to me after I rejected a pull request with unit tests that just printed out the response (thus always returning `True` and being useless):

[Sigh](/img/posts/2017/10/21/two_kinds_of_developers_1.png)

and his boss:

[Sigh multiplied by 10](/img/posts/2017/10/21/two_kinds_of_developers_2.png)

To be fair, he _did_ directly copy my (regression, not unit) test. That was my mistake, indicating that unit tests would be appropriate for a regression. I _was_ freaking out that he in particular did not have working tests though, because he had already submitted the same code that broke the entire repository. My response to this comment was to say to my team lead and director, _please forward all their tickets to me for this repository so that I can do them properly and they can be fired_. It was a very weird sense of calm. No, they weren't fired.

In addition, if they had done a `git blame` on the repository, they will have noted that the 360+ unit tests that _were_ written for the business logic in that repository _was_ written by me. So their boast to create a ticket to make unit tests fell quite flat.

Then there's the way they treat other people, like our QA team when they refactored one entire page without any unit tests (ensuring that the number of possible bugs is at least the combination of 2^N, with N being the number of statements changed):

[yo QA](/img/posts/2017/10/21/two_kinds_of_developers_3_1.png)

This is when one of the incompetent decided to copy and paste code from elsewhere in our codebase, and told us in Bethesda to fix it:

[yo Bethesda](/img/posts/2017/10/21/two_kinds_of_developers_4.png)

My team lead appears to be at his breaking point. For example, a few days ago one incompetent's incompetent team lead asked him to get a pull request reviewed _in the next 4 minutes_. It was _absolutely urgent_ that this code change be merged into our development branch, when we had _two releases to make over the next two days_. Remember, each of our releases is massive, and as we have little to no test coverage in most of our repositories, no regressions, and no continuous integration, it usually takes about a week in order for code to be properly deployed (if properly is the right word to use). There were already bugs caused by the incompetent and the competent's hands were tied with the bleeding in Bethesda:

[ahh](/img/posts/2017/10/21/two_kinds_of_developers_7.png)

When the pull request was approved after three "Request Changes", my team lead asked said incompetent where his team lead was. Can't find him, he replied. So urgent.

So on a pull request one incompetent made with no forethought, afterthought, or thought at all, my team lead said:

[ahhhh](/img/posts/2017/10/21/two_kinds_of_developers_8.png)

---

Long story short, I have found it impossible to respect incompetent software engineers, and awful people in general, to any working degree. I think my colleagues would agree with me (the competent ones of course). For example, on one bugfix pull request that was "auto-approved" and merged in:

[yup](/img/posts/2017/10/21/two_kinds_of_developers_5.png)

and on one pull request whose summary was "Git deleted my shit, rewrote it and did this story as well":

[yup yup](/img/posts/2017/10/21/two_kinds_of_developers_6.png)

I believe that pull request randomly deleted calls from our third-party shipping service, which we need to be able to get shipping rates.

Sometimes I just want to be like:

[Another day at the office](/img/posts/2017/10/21/two_kinds_of_developers_9.gif)

You know why Darth Vader beats all the rebel scum? He's competent at his job.

Thankfully, since my move to the data science team, I've not had to deal with the shit our satellite office spews on a daily basis, or do much interaction with them in any capacity, as our work or lack thereof is more or less unrelated. So my lightsaber remains sheathed.

---

Let's talk about the competent software engineers, and data scientists, that I now work alongside. It's a much happier story.

I will say I was a little worried that things would turn acrimonious after my first interactions with data science. I asked a lot from the data science team when they were adding in the machine learning pipeline into our codebase, including adding more than 120 comments in one large pull request and denying / approving it multiple times between edits (Normally, more than 20 comments in a pull request should or would necessitate significant action). I worried that they would think I was judging them personally or looking down on them in some way.

So one of the messages I strongly underlined from the outset was that I had a high degree of respect for the work they were doing, and the nature of the code itself was because it was (again) a prototype rushed into production by management, and because their strong suit was making things work, not necessarily writing top-notch code on the first pass. I made this clear to the data scientists I worked with on the ground, the head of data science, and the CTO. That seems to have established a baseline of respect.

For new features for our machine learning pipeline, I worked alongside the data scientists and pointed out some basic optimizations they could make that would make their lives easier and their code better. For example, I had set up some git hooks into the project that ran unit tests and linting over the repository, but they were not activated unless you ran a `migrate.sh` in your terminal. This immediately boosted code quality and prevented the frequent "you missed a space" comments in a pull request that grate on people's nerves.

Next came the refactoring portion. I discussed this somewhat in ["My Experience with Refactoring"](/posts/2017/10/18/my_experience_with_refactoring), so let's jump into some examples of code that can be refactored, the refactored code, and why the refactoring made the code better.

---

This code pattern popped up at least once:

```python
things = ${some_long_list}
for thing in things:
  if thing_satisfies(${some_condition}, thing):
    # All of the business logic
```

Why is this sub-optimal? An `if` statement implies that there is going to be an `else` or an `elif` statement in the `for` loop that would be executed. It increases the amount of possible branches the code could go. If you are writing code to be easily testable, this complicates your job. In addition, the `if` statement requires additional nesting within the for loop, which reduces code readability.

I refactored the above using a list comprehension to look like the below:

```python
filtered_things = [
  thing
  for things
  in ${some_long_list}
  if thing_satisfies(${some_condition}, thing)
]
for thing in filtered_things:
  # All of the business logic
```

Notice how the nesting is removed because the filtering is done outside of the main `for` loop, and how the code is a bit more readable.

---

This code pattern turned up a couple times:

```python
if ${convoluted_compound_conditional}:
  # do something special
  if ${cant_do_something}:
    raise Exception('exception message')
# do the normal thing
if ${cant_do_something}:
  raise Exception('exception message')
```

This bit of code was tricky, because the logic to do the special thing and the logic to do the normal thing were both stateful. I knew I didn't want to randomly throw exceptions with the same message (thrown upon the same conditional), and I knew that I didn't want to do this nesting stuff. So I ended up breaking this logic into multiple helper methods:

```python
def _should_do_the_special_thing():
  return ${convoluted_compound_conditional}

def _cannot_move_on():
  if ${cant_do_something}:
    raise Exception('exception message')

def _do_something_special():
  # do something special
  _cannot_move_on()

def _do_something_normal():
  # do something normal
  _cannot_move_on()

if _should_do_the_special_thing():
  _do_something_special()
_do_something_normal()
```

It's a lot more lines of code, but the method names and the breaking up of logic into sensible pieces, as well as the de-duplicated exception handling, improves code readability without impacting performance.

---

Finally, this happened at least once:

```python
def method():
  variable = ${some_initial_state}
  # a whole bunch of complex logic that updates state of variable

  if ${some_condition}
    another_variable = variable
  else:
    another_variable = ${something_totally_different} # that doesn't require any computation whatsoever

  return another_variable
```

Python isn't designed to be a performant language, but it still executes in order and complex computations take time, and I think if time can be saved, it should. So the above became:

```python
def method():
  if ${some_condition}
    return ${something_totally_different} # that doesn't require any computation whatsoever

  variable = ${some_initial_state}
  # a whole bunch of complex logic that updates state of variable

  return variable
```

Yes, there's another return statement and that is kinda iffy, but readability isn't significantly impacted and the method runs faster. So yea.

---

After a few pull requests just full of refactoring, the data scientists began to see the improvement and welcomed the changes. The pull requests they submit now can follow the look and feel of the code and be correct and readable on the first pass. It's like the process of crystallization; you don't need to put in extra work to keep building it properly because the molecules know where to go. We even have a process of adding code that doesn't involve code being slung over the wall.

And you know what? Now, not only do we work rather smoothly together, we also get along rather well on a personal basis too. In fact, I just came back today from a day trip with them to Harper's Ferry in West Virginia (beautiful by the way), and we already have plans to go go-karting, clubbing, and competing in a hackathon together in the coming weeks.
